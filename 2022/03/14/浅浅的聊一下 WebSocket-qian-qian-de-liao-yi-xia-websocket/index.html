
<!DOCTYPE html>
<html lang="en ">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Hexo || 浅浅的聊一下 WebSocket</title>
    <meta name="author" content="John Doe">
    <meta name="description" content=" ">
    <meta name="keywords" content=" ">
    <link rel="icon" href="/image/profile.webp">
    <link rel="stylesheet" href="/css/antd.min.css">
    
    <link rel="stylesheet" href="/css/full-theme.css">
    
    <script src="/js/vue.js"></script>
    <script src="/js/antd.min.js"></script>
<meta name="generator" content="Hexo 6.3.0"></head>

<body>

    <div id="loading"
        style="height: 100vh; width: 100%; position: fixed;display: flex;z-index: 200; justify-content: space-between;">
        <div id="loadleft" style="width: 50%;background-color: #ffffff;transition: width 0.6s ease-out;"></div>
        <div id="loadright" style="width: 50%;background-color: #ffffff;transition: width 0.6s ease-out;"></div>
        <div
            style="position: fixed; height: 100vh; width: 100%;display: flex;justify-content: center;align-items: center;">
            <div id="loadcontent"
                style="width:400px;height:400px;padding:50px;border-radius:50%;display:flex;justify-content:center;align-items:center;border:solid 10px#a3ddfb; text-align:center;opacity:1;transition:opacity 0.3s ease-out;">
                <div>
                    <h2>LOADING...</h2>
                    <p>加载过慢请开启缓存(浏览器默认开启)</p>
                    <div>
                        <img src="/dancingkitty.gif" alt="loading">
                    </div>
                </div>
            </div>
        </div>
    </div>

    <div id="layout">
        <transition name="into">
            <div v-show="show_page" style="display: none;">
                <div id="menu_show">
                     
<nav id="menu">
    <div class="desktop-menu">
        <a href="/">
            <span class="title">Hexo</span>
        </a>
        
        <a href="/">
            <span>
                <a-icon type="home" theme="filled" />
            </span>
            <span>home</span>
        </a>
        
        <a href="/archives">
            <span>
                <a-icon type="folder" theme="filled" />
            </span>
            <span>archives</span>
        </a>
        
    </div>

    <div :class="'phone-menu ' + menu_show" id="phone-menu">
        <div :class="'title'" @click="menu_show=!menu_show">
            <span style="margin-right: 10px;">
                <a-icon type="appstore" theme="filled" />
            </span>
            <span>Hexo</span>
        </div>
        <div class="items" v-show="menu_show">
            
            <a href="/">
                <div class="item">
                    <div style="min-width:20px; max-width:50px; width: 10%">
                        <a-icon type="home" theme="filled" />
                    </div>
                    <div style="min-width:100px;max-width: 150%;width: 20%;">home</div>
                </div>
            </a>
            
            <a href="/archives">
                <div class="item">
                    <div style="min-width:20px; max-width:50px; width: 10%">
                        <a-icon type="folder" theme="filled" />
                    </div>
                    <div style="min-width:100px;max-width: 150%;width: 20%;">archives</div>
                </div>
            </a>
            
        </div>
        <div class="curtain" v-show="menu_show"></div>
    </div>

</nav>
                </div>

                <div id="main">
                     
<link rel="stylesheet" href="/css/post-body.css">
<div class="article">
    <div>
        <h1>浅浅的聊一下 WebSocket </h1>
    </div>
    <div class="info">
        <span class="date">
            <span class="icon">
                <a-icon type="calendar" theme="filled" />
            </span>
            2022/3/14
        </span>

        
        <span class="category">
            <a href="/categories/前端基础">
                <span class="icon">
                    <a-icon type="book" theme="filled" />
                </span>
                前端基础
            </a>
        </span>
        

        

        <span class="tags">
            <span class="icon">
                <a-icon type="tags" theme="filled" />
            </span>
            
            <span class="tag">
                
                <a href="/tags/前端开发" style=color:#03a9f4>
                    前端开发
                </a>
            </span>
            
            <span class="tag">
                
                <a href="/tags/前端" style=color:#00a596>
                    前端
                </a>
            </span>
            
            <span class="tag">
                
                <a href="/tags/思考" style=color:#00a596>
                    思考
                </a>
            </span>
            
            <span class="tag">
                
                <a href="/tags/前端基础" style=color:#ffa2c4>
                    前端基础
                </a>
            </span>
            
            <span class="tag">
                
                <a href="/tags/websocket" style=color:#00a596>
                    websocket
                </a>
            </span>
            
        </span>
        
    </div>

    <div class="content" v-pre>
        <h1 id="浅浅的聊一下-WebSocket"><a href="#浅浅的聊一下-WebSocket" class="headerlink" title="浅浅的聊一下 WebSocket"></a>浅浅的聊一下 WebSocket</h1><blockquote>
<p>第一次看到 <code>ws://</code> 和 <code>wss://</code> 时候，感觉好高级啊，还有这种协议。</p>
</blockquote>
<h2 id="Websocket-历史"><a href="#Websocket-历史" class="headerlink" title="Websocket 历史"></a>Websocket 历史</h2><p>WebSocket是在2008年6月诞生的1。经由IEFT标准化后，2009年chrome 4第一个提供了该标准支持，并默认启用。于2011年由IEFT标准化为<a target="_blank" rel="noopener" href="https://datatracker.ietf.org/doc/html/rfc6455">RFC 6455</a>。</p>
<p>现在的浏览器均已支持该标准。</p>
<h2 id="Websocket-出现的背景"><a href="#Websocket-出现的背景" class="headerlink" title="Websocket 出现的背景"></a>Websocket 出现的背景</h2><p>思考一下我们经常遇到的一种需求场景，要求在某个网页下，网页的内容可以实时更新。</p>
<p>这种情况下，最大众化的方式就是轮询接口了，即通过定时器，定时请求接口，获取到最新的信息后，将内容更新到页面中，如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">setInterval(() =&gt; &#123;</span><br><span class="line">  queryAPI().then(() =&gt; update());</span><br><span class="line">&#125;, 1000);</span><br></pre></td></tr></table></figure>

<p>但是我们知道，这种定时器的延时并不是很精确，而且加上接口的请求时延，实际时间可能不止代码中所预先设定的时间长度，所以这种实时更新是伪实时更新。</p>
<p>除此之外，还有一点可能会经常遇到，即，我们更新信息并总是要更新整个页面上所有可以看到的信息，我们更关注一些经常变化的信息，比如状态，状态的信息可能大小只有几个字节，但是我们轮询接口拿到的信息却是这个页面的所有信息，大小自然不只几个字节，但是除状态以外的信息都可以视作是冗余的。</p>
<p><img src="https://iachieveall.com/upload/2022/03/image-20220314151620372-082384e5f02c4e61b18d8217cf4ef65b.png" alt="状态"></p>
<p>我们实际只需要一个字段，而且即使后端提供只返回状态的接口，但实际在一个请求中还要计算ip报文头的大小，依旧是很占用带宽的。</p>
<p>轮询这种解决方案目前依旧是非常流行，最新的轮询技术是Comet，这种技术虽然可以实现双向通信，但仍然需要反复发出请求。而且在Comet中普遍采用的<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/HTTP%E6%8C%81%E4%B9%85%E9%93%BE%E6%8E%A5">HTTP长连接</a>也会消耗服务器资源2。</p>
<h2 id="Websocket通信模式"><a href="#Websocket通信模式" class="headerlink" title="Websocket通信模式"></a>Websocket通信模式</h2><p>了解网络的都知道，数据传输分为单工、半双工、全双工三种工作模式。</p>
<p>Websocket是基于TCP的，使用全双工通信模式的协议，他使得客户端和服务端之间的数据交换变得更简单。而且，作为一个工作在全双工模式下的协议，服务端可以在建立连接后随时向客户端推送消息。</p>
<p>由于协议是基于TCP的，所以websocket也是需要建连和关闭连接的，但要注意的是，一般在websocket的握手通常指的是：客户端发送一个http请求到服务端，服务端响应后标志这个链接建立起来。而不是指tcp的三次握手。</p>
<p>另外在<a target="_blank" rel="noopener" href="https://datatracker.ietf.org/doc/html/rfc6455">RFC 6455</a> 1.1节「Background」中介绍：WebSocket通过HTTP端口的80和443进行工作，并支持HTTP代理和中介。</p>
<blockquote>
<p>原文：<em><strong>it is designed to work over HTTP ports 80 and 443 as well as to support HTTP proxies and intermediaries</strong></em></p>
</blockquote>
<p>为了实现和HTTP的兼容性，WebSocket握手使用HTTP的Upgrade头将HTTP协议转换成Websocket协议。</p>
<p>作为一种协议，websocket自然也是有其用于<strong>协议控制</strong>的头部信息的，但是相对于HTTP请求每次都要带上完整的头部信息，传输数据时，websocket数据包的头部信息就相对较小，从而降低了控制开销。</p>
<p>相对于前文所提到的轮询接口，websocket可以做到服务端直接向客户端传输数据，省去了客户端发起请求的步骤，同时没有间隔时间，只要服务端内容变化，就可以告知客户端，实时性上有了很大的提高。</p>
<h2 id="Websocket-使用"><a href="#Websocket-使用" class="headerlink" title="Websocket 使用"></a>Websocket 使用</h2><p>WebSocket使用十分简单，只需要关注以下API：</p>
<ol>
<li><code>WebSocket(url[, protocol])</code> 构造函数</li>
</ol>
<p>使用 <code>new WebSocket(xxx)</code> 创建对象时，会同时建立与服务器的连接</p>
<p><img src="https://iachieveall.com/upload/2022/03/image-20220314180647955-7f70842cbce141d8869a3d8167fedb38.png" alt="ws"></p>
<ol start="2">
<li><code>WebSocket.onopen</code> , <code>WebSocket.onclose</code></li>
</ol>
<p>分别对应连接成功、失败时的回调，这里可以做一些初始化、销毁的工作</p>
<ol start="3">
<li><code>WebSocket.onmessage</code></li>
</ol>
<p>实际处理数据是用的该函数</p>
<blockquote>
<p>在数据处理完成后，需要移除回调函数，不然可能会影响到其他地方的处理</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">const ws = new WebSocket(&#x27;ws://sdf.com&#x27;);</span><br><span class="line">function handleData(evt) &#123;</span><br><span class="line">  // handle server data.</span><br><span class="line">&#125;</span><br><span class="line">ws.onmessage = handleData;</span><br><span class="line">ws.addEventListener(&#x27;message&#x27;, handleData);</span><br></pre></td></tr></table></figure>

<ol start="4">
<li><code>WebSocket.send</code></li>
</ol>
<p>主动向服务端发送消息，可以通过send和onmessage进行数据互动，如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">ws.send(&#x27;list&#x27;);</span><br><span class="line">​</span><br><span class="line">ws.onmessage = evt =&gt; &#123;</span><br><span class="line">  const data = evt.data;</span><br><span class="line">  if (data === &#x27;hello&#x27;) &#123;</span><br><span class="line">    console.log(&#x27;world&#x27;);</span><br><span class="line">    return ;</span><br><span class="line">  &#125;</span><br><span class="line">  try &#123;</span><br><span class="line">    const obj = JSON.parse(data);</span><br><span class="line">    switch (obj.type) &#123;</span><br><span class="line">      case &#x27;list&#x27;:</span><br><span class="line">        // do something.</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; catch (ex) &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="5">
<li><code>WebSocket.close</code></li>
</ol>
<p>关闭连接</p>
<blockquote>
<p>Node服务端的实现，这个就参考相关的库吧，比较复杂。</p>
</blockquote>
<h2 id="衍生知识"><a href="#衍生知识" class="headerlink" title="衍生知识"></a>衍生知识</h2><p>http协议至今，主要经历了三个版本。</p>
<ul>
<li><p>http1.0 短连接，单工通信</p>
<ul>
<li>http&#x2F;1.0默认的模型是短连接，每个HTTP请求都由他自己独立完成，下图左1，可以看到每一个http请求都对应了一个建立连接关闭连接的阶段，每一个请求都有TCP握手和挥手的阶段。</li>
<li>在这个模型下，想要做到实时更新页面数据，只能考虑轮询。</li>
</ul>
</li>
</ul>
<!---->

<ul>
<li><p>http1.1 支持长链接，半双工通信</p>
<ul>
<li>1.0之后的版本，1.1会让某个连接保持一定的时间，在这段时间里重复发送一系列请求（下图左2），就是保活。</li>
</ul>
</li>
</ul>
<!---->

<ul>
<li>http2.0 支持多路复用，全双工通信</li>
</ul>
<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4da28c677c604614918658a00305ca6f~tplv-k3u1fbpfcp-watermark.image" alt="Compares the performance of the three HTTP/1.x connection models: short-lived connections, persistent connections, and HTTP pipelining."></p>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p>[1]  <a target="_blank" rel="noopener" href="https://lists.w3.org/Archives/Public/public-whatwg-archive/2008Jun/0165.html">[whatwg] TCPConnection feedback</a></p>
<p>[2]  <a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/WebSocket">wiki</a></p>
<p>[3]  <a target="_blank" rel="noopener" href="https://datatracker.ietf.org/doc/html/rfc6455">RFC 6455</a></p>
<p>[4]  <a target="_blank" rel="noopener" href="https://www.ruanyifeng.com/blog/2017/05/websocket.html">Websocket教程</a></p>
<p>[5]  <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Connection_management_in_HTTP_1.x">HTTP1.x连接管理</a></p>

    </div>

    
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.css">
    <div id="comment">
        <div id="gitalk-container">
        </div>
    </div>
    
</div>
                     
<footer id="footer">
    <div class="footer-wrap">
        <div>
            © 2018 - 2023 Hexo
            <span class="footer-icon">
                <a-icon type="flag" theme="filled" /></span>
            @John Doe
        </div>
        <div></div>
        <div>Based on the <a target="_blank" rel="noopener" href="https://hexo.io/">Hexo Engine</a> & <a
                target="_blank" rel="noopener" href="https://github.com/korilin/hexo-theme-particle">Particle Theme</a></div>
        
    </div>

</footer>

<script src="/js/highlight.min.js"></script>
<script src="/js/particle.js"></script>
                </div>
            </div>
        </transition>
    </div>

    <script>
    new Vue({
        el: "#layout",
        data: {
            show_page: false,
            onload_menu: false,
            menu_show: false,
            card_top: 100
        },
        created: function () {
            var that = this
            window.onload = function () {
                that.show_page = true
                document.getElementById("loadcontent").style.opacity = 0
                setTimeout(function () {
                    document.getElementById("loadleft").style.width = 0
                    document.getElementById("loadright").style.width = 0
                }, 300)
                setTimeout(function () {
                    document.getElementById("loading").style = "display:none"
                }, 600)
            }
        },
        mounted: function () {
            var that = this
            window.addEventListener('scroll', function (e) {
                that.menu_show = false
            })
        },
        methods: {
            home_click: function () {
                window.scrollTo({
                    top: window.innerHeight - 80,
                    behavior: "smooth",
                });
            }
        }
    })
</script>

<script src="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js"></script>
<script>
    const gitalk = new Gitalk({
        clientID: '',
        clientSecret: '',
        repo: 'hexo-theme-particle',      // The repository of store comments,
        owner: 'korilin',
        admin: ['korilin'],
        language: 'en',
        id: location.pathname,      // Ensure uniqueness and length less than 50
        distractionFreeMode: true  // Facebook-like distraction free mode
    })
    gitalk.render('gitalk-container')
</script>

</body>

</html>